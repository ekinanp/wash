package meta

import (
	"github.com/puppetlabs/wash/cmd/internal/find/parser/predicate"
)

/*
If metadata predicates are constructed on metadata values, then metadata
schema predicates are constructed on metadata schemas. Thus, one would expect
that metadata schema predicate parsing is symmetric with metadata predicate
parsing, where instead of walking the metadata values, we walk the metadata
schema. Unfortunately, metadata schemas are JSON schemas. Walking a JSON schema
is more complicated than walking a JSON object because there's a lot more rules
associated with a JSON schema than a JSON object. Thus, it is easier to delegate
to a JSON schema validator.

Consider the expression ".key1 .key2 5 -o 6". This reads "return
true if m['key1']['key2'] == 5 OR m['key1'] == 6". The schema predicate
would return true if "m['key1']['key2'] == number OR m['key1'] == number".
Since we don't care about primitive types, this reduces to
"m['key1']['key2'] == primitive_type OR m['key1'] == primitive_type".
If we normalize all primitive types to the "null" type, then our final schema
predicate is "m['key1']['key2'] == null OR m['key1'] == null". Now if we let
LHS = {"KEY1":{"KEY2":null}} represent the LHS' JSON serialization, and
RHS = {"KEY1":null} represent the RHS' JSON serialization, then our schema
predicate would return true iff the JSON schema validator returned true for
the LHS OR if the validator returned true for the RHS.

Generating the JSON object for a key sequence is tricky because unlike metadata
predicates, child nodes need to know the current key sequence. For example,
in the expression ".key1 .key2 5", we want our generated JSON object to be
{"KEY1": {"KEY2": null}}, and we want this object to be generated by the "5"
node since that is where the key sequence ends. Since our schema predicate
consists of validating JSON objects against the metadata schema, and since those
JSON objects are generated from key sequences, this implies that schema predicates
are generated from key sequences. That is why every schemaP is associated with a
key sequence.

NOTE: We'll need to munge the JSON schema to ensure that we get the right validation.
That munging is done by the schema type.

NOTE: A fundamental invariant of schema predicates is that they always return true
iff their predicate returns true.
*/

type schemaPredicate interface {
	predicate.Predicate
	updateKS(func(keySequence) keySequence)
}

// valueSchemaP is a base class for schema predicates on values
type valueSchemaP struct {
	ks keySequence
}

func newObjectValueSchemaP() *valueSchemaP {
	return &valueSchemaP{
		ks: (keySequence{}).EndsWithObject(),
	}
}

func newArrayValueSchemaP() *valueSchemaP {
	return &valueSchemaP{
		ks: (keySequence{}).EndsWithArray(),
	}
}

func newPrimitiveValueSchemaP() *valueSchemaP {
	return &valueSchemaP{
		ks: (keySequence{}).EndsWithPrimitiveValue(),
	}
}

func (p1 *valueSchemaP) IsSatisfiedBy(v interface{}) bool {
	s, ok := v.(schema)
	if !ok {
		return false
	}
	return s.IsValidKeySequence(p1.ks)
}

/*
"Not(valueSchemaP) == valueSchemaP". To see why, consider the negation of
the predicate counterpart (like "! 5"). Since the predicate's negation still
returns false for a mis-typed value, and since schemaPs operate at the
type-level, both these conditions imply that the type-level predicate, and
hence the schemaP, does not change when the predicate counterpart is negated.
In our example, "! 5" only returns true for numeric values. Thus, its
corresponding schemaP should still expect a numeric value (specifically a
"primitive value" since primitive types are normalized to "null").
*/
func (p1 *valueSchemaP) Negate() predicate.Predicate {
	return p1
}

func (p1 *valueSchemaP) updateKS(updateFunc func(keySequence) keySequence) {
	p1.ks = updateFunc(p1.ks)
}

// schemaPBinaryOp is a base class for schemaP binary operators
type schemaPBinaryOp struct {
	p1 schemaPredicate
	p2 schemaPredicate
}

func (op schemaPBinaryOp) updateKS(updateFunc func(keySequence) keySequence) {
	op.p1.updateKS(updateFunc)
	op.p2.updateKS(updateFunc)
}

// Note that we need the schemaPAnd/schemaPOr classes to ensure that
// De'Morgan's law is enforced. Also, Combine for these classes is not
// implemented b/c it is not needed -- predicateAnd/predicateOr's combine
// handles schema predicates.

type schemaPAnd struct {
	schemaPBinaryOp
}

func newSchemaPAnd(p1 schemaPredicate, p2 schemaPredicate) *schemaPAnd {
	return &schemaPAnd{
		schemaPBinaryOp: schemaPBinaryOp{
			p1: p1,
			p2: p2,
		},
	}
}

func (op *schemaPAnd) IsSatisfiedBy(v interface{}) bool {
	return op.p1.IsSatisfiedBy(v) && op.p2.IsSatisfiedBy(v)
}

func (op *schemaPAnd) Negate() predicate.Predicate {
	return newSchemaPOr(op.p1.Negate().(schemaPredicate), op.p2.Negate().(schemaPredicate))
}

type schemaPOr struct {
	schemaPBinaryOp
}

func newSchemaPOr(p1 schemaPredicate, p2 schemaPredicate) *schemaPOr {
	return &schemaPOr{
		schemaPBinaryOp: schemaPBinaryOp{
			p1: p1,
			p2: p2,
		},
	}
}

func (op *schemaPOr) IsSatisfiedBy(v interface{}) bool {
	return op.p1.IsSatisfiedBy(v) || op.p2.IsSatisfiedBy(v)
}

func (op *schemaPOr) Negate() predicate.Predicate {
	return newSchemaPAnd(op.p1.Negate().(schemaPredicate), op.p2.Negate().(schemaPredicate))
}
