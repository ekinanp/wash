package meta

import (
	"flag"

	"github.com/puppetlabs/wash/api/rql"
	"github.com/puppetlabs/wash/plugin"
)

type SchemaPredicate = func(ValueSchema) bool

/*
ValuePredicate is a wrapper to rql.ValuePredicate that includes
an additional SchemaPredicate method. All rql.ValuePredicate
implementations should embed the ValuePredicateBase type.

RQL users should only care about EvalValueSchema. However, walking
a JSON schema is much harder than walking a JSON object so we have
to implement EvalValueSchema in a different way than EvalValue. That
way is taking advantage of JSON schema validators. Here's how it works.

Given a value predicate AST, assume that all negatable value predicate
expressions are in reduced form (meaning all "NOT" operators are of the
form ["NOT", ValuePredicate]). Consider a leaf in this tree (a ValuePredicate
node or a "NOT" node). Then the leaf's satisfying value schema (SVS) is the
schema of all satisfying values of the predicate generated by the leaf-AST [the
AST consisting of all nodes up to this leaf ignoring any intermediate "AND"/"OR"
operators].

As an example, consider the following AST:
	["object",
		[["key", "foo"],
		["array",
			["some",
			["OR",
				["number", ["=", 5]]]]]],
				["NOT", ["number", [">", 5]]]]]]]
Then the leaves are the "number" and "NOT" nodes under the "OR". Their SVS' are
	* ".foo[] nil" for the "number" node. To see why, notice that this leaf's AST is
			["object",
				[["key", "foo"],
				["array",
					["some",
						["number", ["=", 5]]]]]
	  And {"foo": [5]} is a satisfying value for the leaf-AST's predicate. In fact, all
	  satisfying values will have the general form {"foo": [nil]} (primitive types are
	  normalized to "nil"). We can write this as ".foo[] nil".

	* ".foo[] *" for the "NOT" node. To see why, notice that the leaf AST is
			["object",
				[["key", "foo"],
				["array",
					["some",
						["NOT", ["number", ["=", 5]]]]]]
	  And that {"foo": [6]}, {"foo": [[]]}, {"foo": [{}]} are several satisfying values
	  for the leaf-AST's predicate. In fact, all satisfying values will have the general
	  form {"foo": [*]} where "*" means that the value inside the array can be anything,
	  e.g. an "object", "array" or a primitive value. We can write this as ".foo[] *"

Now let svs be the leaf's SVS. Then its schema predicate will return true iff the schema
supports svs. The AST's final schema predicate will be an "AND"/"OR" of all the generated
leaves' schema predicates as specified in the AST. If the AST doesn't have any "AND"/"OR"
operators, then the schema predicate is just the leaf's schema predicate.

We'll need to traverse the AST to correctly evaluate SVS' and combine the generated schema
predicates. meta.SchemaPredicate lets us do exactly that.
*/
type ValuePredicate interface {
	rql.ValuePredicate
	SchemaPredicate(SatisfyingValueSchema) SchemaPredicate
}

func NewValuePredicate(p ValuePredicate) *ValuePredicateBase {
	return &ValuePredicateBase{
		p: p,
	}
}

func MakeSchemaPredicate(svs SatisfyingValueSchema) SchemaPredicate {
	return func(schema ValueSchema) bool {
		return schema.Supports(svs)
	}
}

// All ValuePredicate implementations should extend this class
type ValuePredicateBase struct {
	schemaPredicate func(ValueSchema) bool
	p               ValuePredicate
}

func (p *ValuePredicateBase) EvalValueSchema(rawSchema *plugin.JSONSchema) bool {
	runningTests := flag.Lookup("test.v") != nil
	if p.schemaPredicate == nil || runningTests {
		p.schemaPredicate = p.p.SchemaPredicate(NewSatisfyingValueSchema())
	}
	schema := NewValueSchema(rawSchema)
	return p.schemaPredicate(schema)
}
